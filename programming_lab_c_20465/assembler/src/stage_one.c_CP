#include "../include/my_libs.h"
#include "../include/glibc_libs.h"


enum S1_PARSER_STATES
{
	ESCAPE = 1,
	QUOTES_START = 2,
	QUOTES_END = 3,
	SIGN = 4,
	COMMA = 5,
	PARSING_NUMBER = 6,
	PARSING_OPERAND = 7
};



int S1ParseSourceFile(FILE *src_file, hash_table_t **symbol_table, hash_table_t **macro_table, 
			memory_image_t *code_img, memory_image_t *data_img)
{
	char curr_line[MAX_LINE_LEN] = {0} ,line_cpy[MAX_LINE_LEN] = {0};
	char *token = NULL;
	int IC = 0, DC = 0, L = 0;
	int line_counter = 0;
	int type = 0;
	int is_error = 0;
	int is_symbol = 0;

	symbol_t curr_symbol;
	const operation_t *curr_op;
	
	while(fgets(curr_line, MAX_LINE_LEN, src_file))
	{
		L = 0;
		is_symbol = 0;
		memset(&curr_symbol, 0, sizeof(symbol_t));
		++line_counter;
		strcpy(line_cpy ,curr_line);	
		token = strtok(line_cpy, "\t\n\r\f ");

		

		if(strchr(token, ':'))
		{
			char *to_copy = NULL;
			if(!S1IsLabelValid(token))
			{
				PrintError(INVALID_LABEL_DECLARATION, line_counter);
				is_error = 1;
				continue;	
			}
			else if(HashFind(*macro_table, token) || HashFind(*symbol_table, token))
			{
				PrintError(SYMBOL_ALREADY_DEFINED, line_counter);
				is_error = 1;
				continue;
			}
			is_symbol = 1;
			token = strtok(token, ":");
			strcpy(curr_symbol.name, token);
			to_copy = strchr(curr_line, ':') + 1;
			memmove(curr_line, to_copy, (strlen(to_copy) + 1));
				
		}


		strcpy(line_cpy, curr_line);
		token = strtok(line_cpy, "\t\n\r\f ");

		if((type = GetInstructionType(token)))
		{
			L = S1HandleInstruction(curr_line, type, 
							DC, symbol_table, data_img);

			if(is_symbol)
			{
				switch(type)
				{
					case DATA:
					case STRING:
						curr_symbol.value = DC;
						curr_symbol.type = type;
						HashInsert(symbol_table ,(void *)&curr_symbol);
						break;
					case ENTRY:
					case EXTERN:
						PrintError(WARNING_ENTRY_EXTERN_SYMBOL, line_counter);
						break;
				}
			}

			if(L < 0)
			{
				PrintError(L, line_counter);
				is_error = 1;
			}
			DC += L;
		}
		
		else if((curr_op = GetOperation(token)))
		{
			type = CODE;
			/*
			TODO: add to symbol table IC + 100
			*/
			/*S1HandleOperation(curr_op, curr_line, symbol_table, &curr_symbol, code_img);*/
		/*}
		else
		{
			PrintError(UNKNOWN_TOKEN, line_counter);
		}*/
		else
		{
			printf("Not Handled: %s\n", curr_line);
		}
		if(L < 0)
		{
			PrintError(L, line_counter);
			is_error = 1;
		}
		if(is_symbol && !is_error)
		{
			switch(type)
			{
				case DATA:
				case STRING:

					DC += L;
					curr_symbol.value = DC;
					curr_symbol.type = type;
					HashInsert(symbol_table ,(void *)&curr_symbol);
					break;
				case ENTRY:
				case EXTERN:
					PrintError(WARNING_ENTRY_EXTERN_SYMBOL, line_counter);
					break;
			}
		}


			
	}
	return is_error;
}

int S1ParseOperation(operation_t *operation, char *operands, char **operands_names)
{
	char curr_operand[MAX_LABEL_LEN] = {0};
	int state = COMMA;
	int i = 0, operands_num = 0;
	while(*operands && isspace(*operands))
	{
		++operands;
	}
	while(*operands)
	{
		switch(state)
		{
			case COMMA:
				if(isspace(*operands))
				{
					++operands;
				}
				else
				{
					curr_operand[i++] = *operands;
					state = PARSING_OPERAND;
				}
				break;
			case PARSING_OPERAND:
				/*if(isspace(*operands))
				{
					++operands;
				}*/
				if(',' == *operands || '\n' == *operands)
				{
					state = COMMA;
					++operands;
					if(*curr_operand)
					{
						strcpy(operands_names[operands_num++], curr_operand);
						memset(curr_operand, 0, MAX_LABEL_LEN);
					}
					
				}
				else
				{
					curr_operand[i++] = *operands;
				}	
				break;
		}
	}

	if(operands_num != operation->operands_num)
	{
		return PARSE_OPERATION_ERR;
	}

	for(i = 0; i < operands_num; ++i)
	{
		if(0 < (ParseOperand(operands_names[i])))
		{

		}
		else
		{
			return INVALID_OPERAND;
		}
	}
	return 0;
}

int ParseOperand(char *operand)
{
	int type = -1;

	if('#' == *operand && IsNumber(operand + 1))
	{
		type = IMMEDIATE_ADDRESSING;
	}
	else if('*' == *operand && IsRegister(operand + 1))
	{
		type = INDIRECT_REG_ADDRESSING;
	}
	else if(IsRegister(operand))
	{
		type = DIRECT_REG_ADDRESSING;
	}
	else if(S1IsLabelValid(operand))
	{
		type = DIRECT_ADDRESSING; 
	}
	return type;
}

int S1HandleOperation(operation_t *operation, char *line, memory_image_t *code_img)
{
	return 0;	
}

int S1ParseString(char *str)
{
	int len = 0;
	int state = QUOTES_START;

	while(*str && isspace(*str))
	{
		++str;
	}
	if('\"' != *str++)
	{
		return -1;
	}
	while(*str && state != QUOTES_END)
	{
		switch(state)
		{
			case ESCAPE:
				state = QUOTES_START;
			case QUOTES_START:
				++len;
				if('\\' == *str)
				{
					state = ESCAPE;
				}
				else if('\"' == *str)
				{
					state = QUOTES_END;
				}
		}
		++str;	
	}
	while(*str && isspace(*str))
	{
		++str;
	}
	if(*str)
	{
		return -1;
	}
	return len - 1;
}

int S1ParseData(char *data_str, int *numbers)
{
	int state = COMMA;
	int L = 0, i = 0;
	char c = 0;
	char curr_number[MAX_LINE_LEN] = {0};
	while(*data_str && isspace(*data_str))
	{
		++data_str;
	}
	while((c = *data_str))
	{
		switch(state)
		{
			case PARSING_NUMBER:
				if(isdigit(c))
				{
					curr_number[i++] = c;
				}
				else if(',' == c || '\n' == c)
				{
					state = COMMA;
					numbers[L++] = atoi(curr_number);
					memset(curr_number, 0, MAX_LINE_LEN);
					i = 0;
				}
				else
				{
					return PARSE_DATA_ERR;
				}
				break;
			case COMMA:
				if(isdigit(c))
				{
					state = PARSING_NUMBER;
					curr_number[i++] = c;
				}
				else if('-' == c || '+' == c)
				{
					state = SIGN;
					curr_number[i++] = c;
				}
				else
				{
					return PARSE_DATA_ERR;
				}
				break;
			case SIGN:
				if(!isdigit(c))
				{
					return PARSE_DATA_ERR;
				}
				curr_number[i++] = c;
				state = PARSING_NUMBER;
				break;
		}
		++data_str;
	}
	if(*curr_number)
	{
		numbers[L] = atoi(curr_number);
		++L;
	}

	return L;
	
}

int S1HandleInstruction(char *line, int type, int DC,
			hash_table_t **symbol_table, memory_image_t *data_img)
{
	int data_length = 0;
	char *token = NULL;
	int i = 0;
	int data_nums[MAX_LINE_LEN / 2] = {0};
	char *str_start = NULL;
	memory_cell_t data_cell;
	symbol_t symbol;

	switch(type)
	{
		case STRING:
			str_start = strstr(line, ".string") + strlen(".string");
			data_length = S1ParseString(str_start);
			if(data_length < 0)
			{
				return PARSE_STRING_ERR;	
			}
			str_start = strchr(line, '\"') + 1;
			for(i = 0; i < data_length; ++i)
			{
				data_cell.address = DC + i;
				data_cell.machine_code = *(str_start + i);
				MemImageInsert(data_img, data_cell);
			}
			data_cell.address = DC + i;
			data_cell.machine_code = '\0';
			MemImageInsert(data_img, data_cell);
			++data_length;
			break;
		case DATA:
			data_length = S1ParseData((strstr(line, ".data") + strlen(".data")), data_nums);
			if(data_length < 0)
			{
				return PARSE_DATA_ERR;
			}
			for(i = 0; i < data_length; ++i)
			{
				data_cell.address = DC + i;
				data_cell.machine_code = data_nums[i];
				MemImageInsert(data_img, data_cell);	
			}
			break;
		case ENTRY:
		case EXTERN:
			token = strtok(NULL, "\t\n\r\f ");
			if(!token && !strtok(NULL, "\t\n\r\f "))
			{
				return PARSE_ENTRY_EXTERN_ERR;
			}
			else if(!S1IsLabelValid(token) || HashFind(*symbol_table, token))
			{
				return INVALID_SYMBOL_NAME; 
			}
			strcpy(symbol.name, token);
			symbol.value = 0;
			symbol.type = type;
			HashInsert(symbol_table ,(void *)&symbol);
			break;
	}
/*
	if(*(symbol->name))
	{
		symbol->type = type;
		switch(type)
		{
			case DATA:
			case STRING:
				symbol->value = DC;
				break;
			case ENTRY:
			case EXTERN:
				symbol->value = 0;
				break;
		}

		HashInsert(symbol_table ,(void *)symbol);
	}	*/

	return data_length;
}


int S1IsLabelValid(char *label)
{
	/*
	char c = 0;    
	do
	{
		c = *label++;
	} while((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'));
	return (c == ':' && '\0' == *label);*/
	return !GetOperation(label) && !GetInstructionType(label);
}


int S1CompSymbolFunc(const void *data , void *param)
{
        user_data_t *my_data = (user_data_t *)data;
        return !strcmp((const char *)my_data->symbol.name ,(const char *)param);
}









